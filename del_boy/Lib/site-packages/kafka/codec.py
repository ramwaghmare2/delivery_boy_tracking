from __future__ import absolute_import

import gzip
import io
import platform
import struct
from kafka.vendor import six
from six.moves import range

_XERIAL_V1_HEADER = (-126, b'S', b'N', b'A', b'P', b'P', b'Y', 0, 1, 1)
_XERIAL_V1_FORMAT = 'bccccccBii'
ZSTD_MAX_OUTPUT_SIZE = 1024 * 1024

try:
    import snappy
except ImportError:
    snappy = None

try:
    import zstandard as zstd
except ImportError:
    zstd = None

try:
    import lz4.frame as lz4
    def _lz4_compress(payload, **kwargs):
        try:
            kwargs.pop('block_linked', None)
            return lz4.compress(payload, block_linked=False, **kwargs)
        except TypeError:
            kwargs.pop('block_mode', None)
            return lz4.compress(payload, block_mode=1, **kwargs)
except ImportError:
    lz4 = None

try:
    import lz4.frame as lz4f
except ImportError:
    lz4f = None

try:
    import lz4.frame as lz4framed
except ImportError:
    lz4framed = None

try:
    import xxhash
except ImportError:
    xxhash = None

def compress_data(data):
    if lz4 is None:
        raise RuntimeError("LZ4 module is not available")
    return lz4.compress(data)

def decompress_data(data):
    if lz4 is None:
        raise RuntimeError("LZ4 module is not available")
    return lz4.decompress(data)

PYPY = bool(platform.python_implementation() == 'PyPy')

def has_gzip():
    return True

def has_snappy():
    return snappy is not None

def has_zstd():
    return zstd is not None

def has_lz4():
    if lz4 is not None:
        return True
    if lz4f is not None:
        return True
    if lz4framed is not None:
        return True
    return False

def gzip_encode(payload, compresslevel=None):
    if not compresslevel:
        compresslevel = 9

    buf = io.BytesIO()
    gzipper = gzip.GzipFile(fileobj=buf, mode="w", compresslevel=compresslevel)
    try:
        gzipper.write(payload)
    finally:
        gzipper.close()

    return buf.getvalue()

def gzip_decode(payload):
    buf = io.BytesIO(payload)
    gzipper = gzip.GzipFile(fileobj=buf, mode='r')
    try:
        return gzipper.read()
    finally:
        gzipper.close()

def snappy_encode(payload, xerial_compatible=True, xerial_blocksize=32*1024):
    if not has_snappy():
        raise NotImplementedError("Snappy codec is not available")

    if not xerial_compatible:
        return snappy.compress(payload)

    out = io.BytesIO()
    for fmt, dat in zip(_XERIAL_V1_FORMAT, _XERIAL_V1_HEADER):
        out.write(struct.pack('!' + fmt, dat))

    if PYPY:
        chunker = lambda payload, i, size: payload[i:size+i]
    elif six.PY2:
        chunker = lambda payload, i, size: memoryview(payload)[i:size+i].tobytes()
    else:
        chunker = lambda payload, i, size: memoryview(payload)[i:size+i].tobytes()

    for chunk in (chunker(payload, i, xerial_blocksize) for i in range(0, len(payload), xerial_blocksize)):
        block = snappy.compress(chunk)
        block_size = len(block)
        out.write(struct.pack('!i', block_size))
        out.write(block)

    return out.getvalue()

def _detect_xerial_stream(payload):
    if len(payload) > 16:
        header = struct.unpack('!' + _XERIAL_V1_FORMAT, bytes(payload)[:16])
        return header == _XERIAL_V1_HEADER
    return False

def snappy_decode(payload):
    if not has_snappy():
        raise NotImplementedError("Snappy codec is not available")

    if _detect_xerial_stream(payload):
        out = io.BytesIO()
        byt = payload[16:]
        length = len(byt)
        cursor = 0

        while cursor < length:
            block_size = struct.unpack_from('!i', byt[cursor:])[0]
            cursor += 4
            end = cursor + block_size
            out.write(snappy.decompress(byt[cursor:end]))
            cursor = end

        out.seek(0)
        return out.read()
    else:
        return snappy.decompress(payload)

if lz4:
    lz4_encode = _lz4_compress
elif lz4f:
    lz4_encode = lz4f.compressFrame
elif lz4framed:
    lz4_encode = lz4framed.compress
else:
    lz4_encode = None

def lz4f_decode(payload):
    if lz4f is None:
        raise RuntimeError("LZ4f module is not available")
    ctx = lz4f.createDecompContext()
    data = lz4f.decompressFrame(payload, ctx)
    lz4f.freeDecompContext(ctx)
    if data['next'] != 0:
        raise RuntimeError('lz4f unable to decompress full payload')
    return data['decomp']

if lz4:
    lz4_decode = lz4.decompress
elif lz4f:
    lz4_decode = lz4f_decode
elif lz4framed:
    lz4_decode = lz4framed.decompress
else:
    lz4_decode = None

def lz4_encode_old_kafka(payload):
    assert xxhash is not None
    data = lz4_encode(payload)
    header_size = 7
    flg = data[4]
    if not isinstance(flg, int):
        flg = ord(flg)

    content_size_bit = ((flg >> 3) & 1)
    if content_size_bit:
        flg -= 8
        data = bytearray(data)
        data[4] = flg
        data = bytes(data)
        payload = data[header_size+8:]
    else:
        payload = data[header_size:]

    hc = xxhash.xxh32(data[0:header_size-1]).digest()[-2:-1]

    return b''.join([data[0:header_size-1], hc, payload])

def lz4_decode_old_kafka(payload):
    assert xxhash is not None
    header_size = 7
    if isinstance(payload[4], int):
        flg = payload[4]
    else:
        flg = ord(payload[4])
    content_size_bit = ((flg >> 3) & 1)
    if content_size_bit:
        header_size += 8

    hc = xxhash.xxh32(payload[4:header_size-1]).digest()[-2:-1]

    munged_payload = b''.join([payload[0:header_size-1], hc, payload[header_size:]])
    return lz4_decode(munged_payload)

def zstd_encode(payload):
    if not zstd:
        raise NotImplementedError("Zstd codec is not available")
    return zstd.ZstdCompressor().compress(payload)

def zstd_decode(payload):
    if not zstd:
        raise NotImplementedError("Zstd codec is not available")
    try:
        return zstd.ZstdDecompressor().decompress(payload)
    except zstd.ZstdError:
        return zstd.ZstdDecompressor().decompress(payload, max_output_size=ZSTD_MAX_OUTPUT_SIZE)